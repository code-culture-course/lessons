# Тестирование логики ввода-вывода

## Проблема тестирования I/O

Тестировать код, использующий `input()` и `print()`, сложно, потому что:
- `input()` ждёт взаимодействия с пользователем
- `print()` отправляет вывод в консоль
- Тесты должны выполняться автоматически без вмешательства человека

## Решение: Разделение логики и I/O

Ключ в том, чтобы **разделить логику** (что делает код) от **I/O** (как он взаимодействует с пользователем).

### Плохо: Логика смешана с I/O

```python
def add_task():
    """Сложно тестировать - ввод и логика перемешаны."""
    task = input("Введите задачу: ")
    if len(task) > 0:
        tasks.append(task)
        print("Задача добавлена!")
    else:
        print("Задача не может быть пустой")
```

Как это протестировать? Вы не можете вызвать это без участия человека.

### Хорошо: Логика отделена от I/O

```python
def validate_task(task):
    """
    Проверяет, валидна ли задача.
    Чистая логика - легко тестировать!
    """
    return len(task.strip()) > 0

def add_task_to_list(tasks, task):
    """
    Добавляет задачу в список, если она валидна.
    Чистая логика - легко тестировать!
    """
    if validate_task(task):
        tasks.append(task)
        return True
    return False

def add_task_interactive():
    """
    Слой I/O - сложно тестировать, но достаточно просто, чтобы довериться.
    """
    task = input("Введите задачу: ")
    if add_task_to_list(tasks, task):
        print("Задача добавлена!")
    else:
        print("Задача не может быть пустой")
```

Теперь вы можете тестировать логику без I/O:

```python
def test_validate_task():
    assert validate_task("Купить молоко") == True
    assert validate_task("") == False
    assert validate_task("   ") == False

def test_add_task_to_list():
    tasks = []
    assert add_task_to_list(tasks, "Купить молоко") == True
    assert len(tasks) == 1
    assert add_task_to_list(tasks, "") == False
    assert len(tasks) == 1  # Всё ещё только одна задача
```

## Принцип проектирования

**Держите I/O в тонких функциях-обёртках. Помещайте логику в чистые функции.**

- **Чистые функции**: Принимают входы, возвращают выходы, без побочных эффектов → Легко тестировать
- **Обёртки I/O**: Вызывают чистые функции, обрабатывают `input()`/`print()` → Можно доверять, если простые

## Тестирование файловых операций

Для файловых операций тестируйте логику обработки данных, а не сам файловый I/O.

### Пример: Обработка данных из файла

```python
def parse_log_line(line):
    """
    Парсит строку лога в словарь.
    Чистая логика - легко тестировать!
    """
    parts = line.strip().split(" | ")
    if len(parts) == 2:
        return {"timestamp": parts[0], "message": parts[1]}
    return None

def load_log_file(filename):
    """
    Загружает и парсит файл лога.
    I/O + логика смешаны - сложнее тестировать.
    """
    file = open(filename, "r", encoding="utf-8")
    lines = file.readlines()
    file.close()
    
    entries = []
    for line in lines:
        entry = parse_log_line(line)
        if entry:
            entries.append(entry)
    return entries
```

Тестируем парсер:

```python
def test_parse_log_line():
    line = "2026-01-20 | Система запущена"
    result = parse_log_line(line)
    assert result["timestamp"] == "2026-01-20"
    assert result["message"] == "Система запущена"
    
    invalid = "некорректная строка"
    assert parse_log_line(invalid) == None
```

## Пример: Тестируемый менеджер задач

См. [task_manager_testable.py](task_manager_testable.py) для полного примера тестируемого I/O кода.

См. [test_task_manager.py](test_task_manager.py) для соответствующих тестов.

## Ключевые выводы

1. **Разделяйте задачи**: Логика vs I/O
2. **Тестируйте логику**: Чистые функции легко тестировать
3. **Доверяйте простым обёрткам I/O**: Если они просто вызывают чистые функции и обрабатывают I/O, всё в порядке
4. **Думайте слоями**:
   - Слой обработки данных (чистые функции) ← Тестируйте это
   - Слой I/O (тонкие обёртки) ← Держите простым, доверяйте

## Запуск тестов

```bash
# Установите pytest, если ещё не сделали этого
pip install pytest

# Запустите тесты
pytest test_task_manager.py -v
```

## Дополнительное чтение

Этот подход называется **паттерн Humble Object** или **Ports and Adapters**:
- I/O — это "скромная" часть (сложно тестировать, держите простой)
- Логика — это "умная" часть (легко тестировать, здесь живёт сложность)

По мере развития как разработчик вы узнаете более продвинутые техники тестирования (мокинг, внедрение зависимостей), но это простое разделение послужит вам хорошую службу на данный момент.
